---
theme: gaia
paginate: true
<!-- backgroundColor: #ffffff -->
transition: fade
footer: Betriebssysteme, Tutorat 4, Gruppe 6, [juergmatth@gmail.com](juertmatth@gmail.com), UniversitÃ¤t Freiburg Technische FakultÃ¤t
style: |
  h1 { color: #b37650; font-size: 80px; text-align: center; }
  h2 { color: #b37650; font-size: 60px; text-align: left; margin-top: 0px; margin-bottom: 0px; line-height: 0px; line-height: 60px;}
  h3 { color: #5c4c89; font-size: 40px; text-align: left; margin-top: 10px; margin-bottom: 20px; line-height: 40px;}
  h4 { color: #b37650; font-size: 20px; text-align: center; margin-top: 0px; margin-bottom: 20px; line-height: 0px; font-weight: normal; }
  h5 { color: #b38336; font-size: 30px; text-align: left; margin-top: 40px; margin-bottom: 30px; line-height: 0px; font-weight: normal; }
  a { color: #b37650; }
  strong { color: #5c4c89; }
  em { color: #b37650; }
  footer { color: #5c4c89; font-size: 20px; text-align: center; }
  ul { color: #252a2f; list-style: none; font-size: 25px; margin-bottom: 0px; }
  p { color: #252a2f; list-style: none;  font-size: 25px; text-align: center; margin-top: 0px; }
  ul li::before {
    content: "\1F784";
    color: #b37650;
    font-size: 25px;
    font-weight: bold;
    display: inline-block;
    width: 1em;
    margin-left: -1em;
  }
  section::after {
      color: #5c4c89;
      font-weight: bold;
      text-shadow: 0 0 0px #000;
  }
  code {
    background: #7f6e81;
    color: #282e33;
  }
  :root {
    --color-background: #ffffff;
    --color-foreground: #7f6e81;
    --color-highlight: #F96;
    --color-dimmed: #6a6458;
  }

---

# Tutorat 4 <!--fit-->
### Zustandsdiagramme, DMA <!--fit-->

<!--_class: lead-->
<!--big-->
![bg right:30%](_resources/background_2.png)

---

# Vorbereitung

<!--_class: lead-->
<!--big-->
![bg right:30%](_resources/background_2.png)
<!-- _backgroundColor: #7b738f; -->

---

## Vorbereitung
### Mealy und Moore

#### ![height:400px](_resources/_2021-11-22-14-17-21.png) ![height:200px](_resources/_2021-11-22-15-00-42.png) ![height:200px](_resources/_2021-11-22-15-01-15.png)
#### **Source:** https://earth.informatik.uni-freiburg.de/uploads/es-2122/03_finitestate.html

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### Mealy und Moore

- **PrimÃ¤re EingÃ¤nge:** Bekommen Werte *â€žvon auÃŸenâ€œ*.
- **PrimÃ¤re AusgÃ¤nge:** Liefern Werte *â€žnach auÃŸenâ€œ*.
- **SekundÃ¤re EingÃ¤nge:** Sind mit den DatenausgÃ¤ngen der Flipflops im Register verbunden. Auf diese Weise kann der aktuelle Zustand des Schaltkreises in den *Ãœbergangs- und Ausgabefunktionen* berÃ¼cksichtigt werden.
- **SekundÃ¤re AusgÃ¤nge:** Sind mit den DateneingÃ¤ngen der Flipflops verbunden. Durch sie wird der *nÃ¤chste Zustand* des Schaltkreises spezifiziert.

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### Mealy und Moore

##### Beispiel Erweiterte RETI (Aufgabe 1 Ãœbungsblatt)
- **Eingabevektor:** $i = (/mreg, /mw, a31)$ (*= PrimÃ¤re EingÃ¤nge*)
- **Ausgabevektor:** $o = (/SMack, /SDdoe, /SMw)$ (*= PrimÃ¤re AusgÃ¤nge*)
- **Zustandsvektor:** $z = (z_0, z_1, z_2)$
- **Ãœbergangsfunktion:** $\delta: Z \times I \rightarrow Z$
- **Ausgabefunktion (Mealy):** $\lambda: Z \times I \rightarrow O$
  - auf den Kanten stehen *Inputsymbole* und *Outputsymbole*, dafÃ¼r stehen in den ZustÃ¤nden nur die Zustandsbezeichnungen
- **Ausgabefunktion (Moore):** $\lambda: Z \rightarrow O$
  - auf den Kanten stehen *Inputsymbole*, dafÃ¼r stehen in den ZustÃ¤nden *Zustandsbezeichnungen* und *Outputsymbole*

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### Anzahl Formeln
- **Anzahl Modelle / Zeilen in Wahrheitstabelle:** $2^{\text{\# Variablen}}$
- **Anzahl Aussagenlogische Formeln:** $2^{\text{\#Zeilen}} = 2^{2^{\text{\#Variablen}}}$
  - bei 3 **Aussagenlogischen Variablen** gibt es $2^3=8$ Zeilen in der Wahrheitstabelle und damit $2^{(2^3)}=256$ verschiedenen Aussagenlogische Formeln, da man diese $2^3$ Zeilen auch nochmal auf **exponentiell** $2^{\text{\#Zeilen}}$ viele verschiedene Arten belegen kann

![_2021-11-22-18-46-04](_resources/_2021-11-22-18-46-04.png)

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### Minterme und Maxterme
- **16 mÃ¶gliche Logikfunktionen fÃ¼r 2 Aussagenlosche Variablen:**
  ![_2021-11-22-18-01-18](_resources/_2021-11-22-18-01-18.png)
- $f1$, $f2$, $f4$ und $f8$ sind **Minterme** (fÃ¼r genau eine *Variation* der Eingabewerte den Wert $1$)
- $f7$, $f11$, $f13$ und $f14$ sind **Maxterme** (fÃ¼r genau eine *Variation* der Eingabewerte den Wert $0$)

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### Minterme und Maxterme
- die 4 **Minterme** kÃ¶nnen als **Konjunktionen** dargestellt werden:
  $m_{0}(a, b)=\bar{a} \cdot \bar{b}, m_{1}(a, b)=\bar{a} \cdot b, m_{2}(a, b)=a \cdot \bar{b}, m_{3}(a, b)=a \cdot b$
- die 4 **Maxterme** kÃ¶nnen als **Disjunktionen** dargestellt werden:
  $M_{0}(a, b)=\bar{a} + \bar{b}, M_{1}(a, b)=\bar{a} + b, M_{2}(a, b)=a + \bar{b}, M_{3}(a, b)=a + b$
- **Vergleich:**
  $
  \begin{array}{|c|c||c|c|}
  \hline a & b & Â¬a \cdot b & a + Â¬b\\
  \hline 0 & 0 & 0 & 1\\
  0 & 1 & 1 & 0 \\
  1 & 0 & 0 & 1 \\
  1 & 1 & 0 & 1 \\
  \hline
  \end{array}
  $
- $Â¬(Â¬a \wedge b) = a \vee Â¬b$: "alles auÃŸer" $Â¬a \wedge b$ ist $1$ **âžž** ($a=0, b=1$) ist als einziges $0$


<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### DNF und KNF

- aus drei **Basistypen** (Disjunktion, Konjunktion oder Negation) lassen sich alle anderen **Logikfunktion** erzeugen
- Jede Logikfunktion $f: B^{2} \rightarrow B$ lÃ¤sst sich in **disjunktiver Normalform (DNF):**
$f(a, b)=f(0,0) \cdot \bar{a} \cdot \bar{b}+f(0,1) \cdot \bar{a} \cdot b+f(1,0) \cdot a \cdot \bar{b}+f(1,1) \cdot a \cdot b$
- Und auch in **konjunktiver Normalform (KNF):**
$f(a, b)=(f(0,0)+a+b) \cdot(f(0,1)+a+\bar{b}) \cdot(f(1,0)+\bar{a}+b) \cdot(f(1,1)+\bar{a}+\bar{b})$
- man mÃ¶chte **Logische Funktion** (Wertetabelle) mit mÃ¶glichst wenig Schaltelementen realisieren **âžž** schauen, ob **DNF** oder **KNF** kÃ¼rzer ist, je nachdem, ob die Logische Funktion (Menge an Formeln) mehr oder weniger **Modelle** besitzt, also mehr oder weniger Variationen aus Aussagenlogischen Variablen besitzt, die $1$ ergeben

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### DNF und KNF
![height:400px](_resources/_2021-11-22-21-07-17.png)
#### https://de.wikipedia.org/wiki/Disjunktive_Normalform#/media/Datei:Knf+dnf.svg

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### DNF und KNF
- **Beispiel:** "**hÃ¶chstens** 2 wahre aussagenlogische Variablen"
  - **DNF:** $(Â¬a\cdot Â¬b\cdot Â¬c)+(Â¬a\cdot Â¬b\cdot c)+(Â¬a\cdot b\cdot Â¬c)+(Â¬a\cdot b\cdot c)+(a\cdot Â¬b\cdot Â¬c)+(a\cdot Â¬b\cdot c)+(a\cdot b\cdot Â¬c)$
  - **KNF:** $(Â¬a+Â¬b+Â¬c)$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### Klauseln, Literale, Klausel Normalform

- **Atom:** *Atomare Formel* (=Formel, die nur aus einer einzigen *Aussagenlogischen Variable* besteht)
- **Literal:** (mÃ¶glicherweise *negierte*) *atomare Formel*
- **Klausel:** *Disjunktion* von *Literalen*
- **Klausel Normalform:** Formel in *konjunktiver Normalform (KNF)*, bei der die *Konjunktionen* jeweils in *Mengenschreibweise* zusammengefasst sind
  - $((a \vee b) \wedge(b \vee c) \wedge(a \vee \neg d \vee \neg e) \wedge d)$
 **âžž** $\{\{a, b\},\{b, c\},\{a, \neg d, \neg e\},\{d\}\}$
  - $\{\neg(P \vee(\neg(P \wedge Q) \wedge \neg R))\}$ **âžž** $\{\{\neg P\},\{\neg(\neg(P \wedge Q) \wedge \neg R)\}\}$ **âžž** $\{\{\neg P\},\{\neg \neg(P \wedge Q), \neg \neg R\}\}$ **âžž** $\{\{\neg P\},\{(P \wedge Q), R\}\}$ **âžž** $\{\{\neg P\},\{P, R\},\{Q, R\}\}$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### BinÃ¤reprÃ¤fixe

- Speicher wird in **Byte** = $8$ **Bit** angegeben
- **DezimalprÃ¤fixe:** Kilobyte [kB], Megabyte [MB], Gigabyte [GB], Terabyte [TB], Petabyte [PB], Exabyte [EB]
- **BinÃ¤rprÃ¤fixe:** Kibibyte [KiB], Mebibyte [MiB], Gibibyte [GiB], Tebibyte [TiB], Pebibyte [PiB], Exbibyte [EiB]
- **Einheit umrechnen:**
`1 000 000 000 kB` $\xLeftarrow{\cdot 1000}$ `1 000 000 MB` $\xLeftarrow{\cdot 10^3}$ `1 000 GB` $\xLeftarrow{\cdot 10^3}$ `1 TB`
$\Downarrow \cdot 10^3$
`1 000 000 000 000 B`
$\Downarrow \operatorname{:} 2^{10}$
`976 562 500 KiB` $\xRightarrow{\operatorname{:} 1024}$ `953 674,32 MiB` $\xRightarrow{\operatorname{:} 2^{10}}$ `931,32 GiB` $\xRightarrow{\operatorname{:} 2^{10}}$ `0,91 TiB`

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### BinÃ¤reprÃ¤fixe

- $1\cdot2^{10}B=1KiB$, $1\cdot2^{20}=1MiB$, $1\cdot2^{30}=1GiB$ etc.
- $1\cdot10^3B=1KB$, $1\cdot10^{6}B=1MB$, $1\cdot10^{9}B=1GB$ etc.
- **Windows** verwendet $GiB$, schreibt aber $GB$ hin, einige **Linux Distributionen** auch, der **Manjaro Installer** aber z.B. $GiB$
- wird von **Festplattenherstellern** genutzt, um $100GB$ draufzuschreiben, was viele fÃ¤lschlicherweise als $GiB$ interpretieren, aber nur $(100 \cdot 1000 \cdot 1000 \cdot 1000) / 1024 / 1024 / 1024 \approx 93.13GiB$ tatsÃ¤chlich zu liefern
- **Unterschied** wird immer grÃ¶ÃŸer, z.B. zwischen GB und GiB sind es $7,4\%$
- bei **SD-Karten** wird in GiB angegeben (512GiB)
- **Arbeitsspeicher** wird in GiB angegebn (8 GiB Arbeitsspeicher)

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Vorbereitung
### DMA (Direct Memory Access)

![height:200px](_resources/_2021-11-23-14-07-18.png)
- direkt ohne **Umweg** Ã¼ber **CPU**
- Funktioniert nur, wenn CPU Daten im **Cache** findet. Wenn sie an den **Hauptspeicher** gehen muss, dann gibts **Buskonflikt**
- Bevor eine **Adresse** Ã¼ber **Adressbus** an **Hauptspeicher** geht, geht Adresse zunÃ¤chst an den **Cache**. Cache meldet zurÃ¼ck, es gibt nen **Cache Hit** **ðŸ ’** man kann direkt liefern

<!--small-->
![bg right:10%](_resources/background_2.png)

---

# Ãœbungsblatt

<!--_class: lead-->
<!--big-->
![bg right:30%](_resources/background_2.png)
<!-- _backgroundColor: #7b738f; -->

---

## Ãœbungsblatt
### Aufgabe 1

##### Vorgehen fÃ¼r Ãœbergangsfunktion
- fÃ¼r $z_x$ schaue, wo $z_x$ in der Spalte $1$ ist und notiere diese *ZustÃ¤nde* des Zustandsdiagrams
- gehe zu diesen *notierten ZustÃ¤nden* $z_x$ und notiere die *Conditions* und die *adjazenten VorgÃ¤ngerzustÃ¤nde* $z_x'$, die auf den *eingehenden Kanten* stehen bzw. Ã¼ber sie erreichbar sind
- bilde *Disjunktive Normalform* fÃ¼r *nÃ¤chsten Zustand* $z_x'$ aus *Conditions* und *der Kodierung der adjazenten VorgÃ¤ngerzustÃ¤nde* $(z_0, \~z_1, \~z_2)$
- (*Minimieren*)

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 1

##### Vorgehen fÃ¼r Moore Ausgabefunktion
- schaue welche *ZustÃ¤nde* $z_x$ das *Outputsignal* $/S_i$ haben und notiere diese *ZustÃ¤nde* des Zustandsdiagrams
- bilde *Disjunktive Normalform* fÃ¼r Outputsignal $/S_i$ aus der *Kodierung der notierten ZustÃ¤nde* $(\~z_0, z_1, z_2)$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 1

![height:400px](_resources/_2021-11-22-15-04-52.png) ![height:200px](_resources/_2021-11-22-15-04-13.png)
- $mreq$ bedeutet, dass das Eingangssignal $/mreq = 0$ entspricht

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 1

- $z_{0}^{\prime}=\left(z_{0} \wedge \neg z_{1} \wedge \neg z_{2} \wedge / m r e q\right) \vee\left(z_{0} \wedge \neg z_{1} \wedge \neg z_{2} \wedge / a 31\right) \vee\left(\neg z_{0} \wedge \neg z_{1} \wedge z_{2} \wedge / m r e q\right) \vee\left(\neg z_{0} \wedge z_{1} \wedge z_{2} \wedge / m r e q\right)$
- $z_{1}^{\prime}=\left(z_{0} \wedge \neg z_{1} \wedge \neg z_{2} \wedge m r e q \wedge m w \wedge a 31\right) \vee\left(\neg z_{0} \wedge z_{1} \wedge \neg z_{2}\right) \vee\left(\neg z_{0} \wedge z_{1} \wedge z_{2} \wedge m r e q\right)$
- $z_{2}^{\prime}=\left(\neg z_{0} \wedge \neg z_{1} \wedge \neg z_{2}\right) \vee\left(\neg z_{0} \wedge z_{1} \wedge \neg z_{2}\right) \vee\left(\neg z_{0} \wedge \neg z_{1} \wedge z_{2} \wedge m r e q\right) \vee\left(\neg z_{0} \wedge z_{1} \wedge z_{2} \wedge m r e q\right)$
- $/ S M a c k=\neg\left(\left(\neg z_{0} \wedge \neg z_{1} \wedge \neg z_{2}\right) \vee\left(\neg z_{0} \wedge z_{1} \wedge \neg z_{2}\right)\right)$
- $/ S D d o e=\neg\left(\left(\neg z_{0} \wedge \neg z_{1} \wedge \neg z_{2}\right) \vee\left(\neg z_{0} \wedge \neg z_{1} \wedge z_{2}\right)\right)$
- $/ S M w=\neg\left(\neg z_{0} \wedge z_{1} \wedge \neg z_{2}\right)$
- Weil die **Ausgangssignale** alle **active-low** sind, mÃ¼ssen deren **DNF** die zu $1$ fÃ¼hren komplett **negiert** werden

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 2a) - Umsetzung mit Interrupt
- Taktrate des Prozessors = $8\cdot 10^{8}\dfrac{1}{s}$
- DatenÃ¼bertragungsrate der Festplatte = $8\cdot 2^{20}\dfrac{B}{s}$
```
|8*32Bit=32Byte|1000Takte____|___________|eine Ãœbertragung
|1*2^(-18)s____|1,25*10^(-6)s|___________|einzelne Zeitdauern
|20*2^(-18)s_____________________________|Gesamtdauer
```

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 2a) - Umsetzung mit Interrupt

##### Zeit der Festplatte (Dauer der 32Byte Ãœbertragung)

$1s\overset{\wedge}{=}8 \cdot2^{20}B$
$\Downarrow \cdot2^{-18}$
$1\cdot 2^{-18}s\overset{\wedge}{=}8 \cdot2^{2}B = 32B$

##### Gesamtdauer

$1\cdot 2^{-18}s\overset{\wedge}{=}5\%$
$\Downarrow \cdot 20$
$20\cdot 2^{-18}s\overset{\wedge}{=} 100\%$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 2a) - Umsetzung mit Interrupt

##### Zeit des Prozessors (Dauer der 1000 Takte)

$1s\overset{\wedge}{=}8\cdot 10^{8} Takte$
$\Downarrow \cdot 1,25\cdot 10^{-6}$
$1,25\cdot 10^{-6}s\overset{\wedge}{=}1000 Takte$

##### Anteil der CPU-Zeit

$\dfrac{1,25\cdot 10^{-6}s}{20\cdot 2^{-18}s}=0.01638\approx1,64\%$

##### MusterlÃ¶sung
$\displaystyle0.05 \cdot \frac{2^{18} \cdot \frac{1}{800000} \mathrm{~s}}{1 \mathrm{~s}}=\frac{2^{18}}{16000000}=0.016384$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 2b) - Umsetzung mit DMA
- Taktrate des Prozessors = $8\cdot 10^{8}\dfrac{1}{s}$
- DatenÃ¼bertragungsrate der Festplatte = $8\cdot 2^{20}\dfrac{B}{s}$
```
|1500Takte|16KB|500Takte______|_________|eine Ãœbertratung
|1500+500Takte_____|16KiB_____|_________|eine Ãœbertratung zusammengefasst
|0.25*10^(-5)s_____|1*2^(-9)s_|_________|einzelne Zeitdauern
|20*2^(-9)s_____________________________|Gesamtdauer
```

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 2b) - Umsetzung mit DMA

##### Zeit der Festplatte (Dauer des 16KiB Block)

$1s\overset{\wedge}{=}8\cdot 2^{20}B$
$\Downarrow \cdot 2^{-9}$
$1\cdot 2^{-9}s\overset{\wedge}{=}8\cdot 2^{11}B = 16KiB$

##### Gesamtdauer

$1\cdot 2^{-9}s\overset{\wedge}{=}5\%$
$\Downarrow \cdot 20$
$20\cdot 2^{-9}s\overset{\wedge}{=}100\%$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 2b) - Umsetzung mit DMA

##### Zeit des Prozessors (Dauer der 2000 Takte)

$1s\overset{\wedge}{=}8\cdot 10^{8}Takte$
$\Downarrow \cdot 0,25\cdot 10^{-5}$
$0,25\cdot 10^{-5}s\overset{\wedge}{=}2\cdot 10^{3}Takte$

##### Anteil der CPU-Zeit

$\dfrac{0,25\cdot 10^{-5}s}{20\cdot 2^{-9}s}=0.000064=0.0064\%$

##### MusterlÃ¶sung
$\displaystyle0.05 \cdot \frac{2^{9} \cdot \frac{1}{400000} \mathrm{~s}}{1 \mathrm{~s}}=\frac{2^{9}}{8000000}=0.000064$

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 3
- Interrupts mit **verschiedenen PrioritÃ¤ten**
- Verwendung **Interrupt Controller**
- Signal $Int$ **ðŸ ’** Interrupt Controller **signalisiert** dem Prozessor, dass **Interrupt anliegt**, der Prozessor **unterbrechen** darf
  - wenn **keine ISR** auf Prozessor **aktiv** ist
  - wenn an Interrupt-Controller anliegender Interrupt **hÃ¶here PrioritÃ¤t** hat als aktuell auf Prozessor laufende ISR
- Signal $/INTA$ **ðŸ ’** nach **Abarbeiten von Interrupt** signalisiert Prozessor dem Interrupt Controller, dass ISR **beendet** wurde
- max. 255 **Hardware Interrupts** mit PrioritÃ¤ten $0$ bis $254$
- Solange Interrupt $INT_j$ **nicht verarbeitet** darf I/O-GerÃ¤t $j$ **keinen** weiteren Interrupt auslÃ¶sen

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 3a)
> Methode Ã¼berlegen, wie **Interrupt Controller** feststellen kann, ob auf dem Prozessor aktuell gerade **keine ISR** lÃ¤uft
- **8-Bit-ZÃ¤hler**
  - Signale **up** und **down**, (up=1, down=0) **ðŸ ’** ZÃ¤hler zÃ¤hlt bei steigender Flanke **hoch**, (up=0, down=1) **ðŸ ’** ZÃ¤hler zÃ¤hlt bei steigender Flanke **runter**

##### LÃ¶sungsweg
- mit $/reset$ Signal **ZÃ¤hler** mit $0$ initiliasieren
- $INT$ **âžž** ZÃ¤hler **inkrementieren**
- $/INTA$ (Interrupt Acknowledge) **âžž**  ZÃ¤hler **dekrementieren**
- wenn $\text{ZÃ¤hler} = 0$ **âžž** **Controller** weiÃŸ, dass **keine** ISR auf der CPU lÃ¤uft

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 3b)
> Ausreichend, um **Interrupt Controller** zu implementieren? LÃ¶sung entwerfen, wo Interrupt Controller **Signal** $INT$ **immer korrekt** setzt.

- Interrupt Controller hat Internen Speicherbereich mit $256$ **Speicherzellen**
  - Ã¼ber 8-Bit **Adressen** angesprochen, **Speicherzellen** mit **8-Bit Wortbreite**
- **8-Bit ZÃ¤hler** aus a) weiterverwendbar
- **Interrupt-Controller** speichert **Nummer** des anliegenden **Interrupts** mit der **hÃ¶chsten PrioritÃ¤t** in Register `IVN` und **PrioritÃ¤t** in einem Register `PR` (also **PrioritÃ¤t** des Interrupts, der der CPU Ã¼bergeben wird)

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 3b)
##### LÃ¶sungsweg
- **Szenario:**
  - mehr als ein **Interrupt** ($\text{ZÃ¤hler} > 1$) gleichzeitig in **ISR** **angefangen** ($INT_i$ von $INT_j$ mit **hÃ¶herer PrioritÃ¤t** unterbrochen)
  - vor Eintreffen von $INT_k$ min. eine **ISR** ($INT_j$) **beendet** (und $INT_i$ fortgesetzt **ðŸ ’** sobald $INT_k$ eintrifft, weiÃŸ Controller **nicht**, ob aktuell ausgefÃ¼hrte ISR **hÃ¶here PrioritÃ¤t** hat)
- **Idee:** Speicher als Stack fÃ¼r Historie Ã¼ber die Ã¼bergebenen Interrupts
  - oben auf dem Stack liegt immer die **PrioritÃ¤t** des aktuell in der CPU abgearbeiteten Interrupts, welche immer die **hÃ¶chste PrioritÃ¤t** aller **schon gestarteten** aber noch **nicht beendeten** ISR hat

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Ãœbungsblatt
### Aufgabe 3b)
##### LÃ¶sungsweg
- bei **Senden** von $INT$ **ðŸ ’** Inhalt von Register `PR` auf Stack des Controllers
   - **Stack** des **Controllers** ist nicht der **Stack** der **CPU**!
- bei **Empfangen** von $/INTA$ **ðŸ ’** oberster Eintrag vom Stack **entfernt**
- durch **Vergleich** von **PR** mit **obersten Eintrag des Stacks** wird bestimmt, ob ankommender $INT_l$ an CPU weitergeleitet wird
  - **ZÃ¤hler** aus a) fÃ¼r die **Adressierung des Stacks** genutzt, da **kein** eigenes Stackpointer Register gegeben

<!--small-->
![bg right:10%](_resources/background_2.png)

---

# Quellen

<!--_class: lead-->
<!--big-->
![bg right:30%](_resources/background_2.png)
<!-- _backgroundColor: #7b738f; -->

---

## Quellen
### Wissenquellen

- https://de.wikipedia.org/wiki/Klausel-Normalform

<!--small-->
![bg right:10%](_resources/background_2.png)

---

## Quellen
### Bildquellen

- Von WikiBasti 21:12, 21. Jan. 2011 (CET) und JensKohl - Datei:KNF+DNF.png, CC-by-sa 2.0/de, https://de.wikipedia.org/w/index.php?curid=5947670

<!--small-->
![bg right:10%](_resources/background_2.png)

---

# Vielen Dank fÃ¼r eure Aufmerksamkeit!
# :penguin:

<!--_class: lead-->
<!--big-->
![bg right:30%](_resources/background_2.png)
<!-- _backgroundColor: #7b738f; -->
